apiVersion: batch/v1
kind: Job
metadata:
  name: authentik-db-init
  labels:
    app.kubernetes.io/name: authentik
    app.kubernetes.io/component: db-init
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation,HookSucceeded
    argocd.argoproj.io/sync-wave: "0"
    # Jobs are effectively immutable once created (selector + pod template). Ensure ArgoCD
    # recreates the Job rather than attempting to patch immutable fields.
    argocd.argoproj.io/sync-options: Replace=true
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: authentik
        app.kubernetes.io/component: db-init
    spec:
      restartPolicy: Never
      containers:
        - name: db-init
          image: {{ required "dbInit.image is required" .Values.dbInit.image | quote }}
          imagePullPolicy: {{ .Values.dbInit.imagePullPolicy | default "IfNotPresent" | quote }}
          securityContext:
            runAsNonRoot: true
            runAsUser: 70
            runAsGroup: 70
            allowPrivilegeEscalation: false
          env:
            - name: PGHOST
              value: cnpg-main-rw.apps.svc.cluster.local
            - name: PGPORT
              value: "5432"
            - name: PGUSER
              valueFrom:
                secretKeyRef:
                  name: cnpg-main-superuser
                  key: username
            - name: PGPASSWORD
              valueFrom:
                secretKeyRef:
                  name: cnpg-main-superuser
                  key: password
            - name: APP_DB
              value: authentik
            - name: APP_OWNER
              value: authentik
          volumeMounts:
            - name: app-db-auth
              mountPath: /secrets/app-db-auth
              readOnly: true
          command:
            - /bin/sh
            - -ec
            - |
              echo "Waiting for Postgres RW endpoint (${PGHOST}:${PGPORT})..."

              i=0
              while [ "$i" -lt 60 ]; do
                if pg_isready -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}" >/dev/null 2>&1; then
                  break
                fi
                i=$((i+1))
                sleep 2
              done

              pg_isready -h "${PGHOST}" -p "${PGPORT}" -U "${PGUSER}"

              role_password_file="/secrets/app-db-auth/password"
              if [ ! -f "${role_password_file}" ]; then
                echo "Missing ${role_password_file} (Secret authentik-postgres-auth must exist with key 'password')."
                exit 1
              fi

              role_password="$(cat "${role_password_file}")"
              if [ -z "${role_password}" ]; then
                echo "Secret authentik-postgres-auth/password is empty."
                exit 1
              fi

              echo "Ensuring role ${APP_OWNER} exists and has the expected password..."

              # NOTE: Don't use `-Atc` here. `-c` consumes the next argument, so putting
              # other flags (like `-v`) after it breaks option parsing.
              create_role_sql="$(psql -v ON_ERROR_STOP=1 -d postgres -A -t \
                -v role="${APP_OWNER}" -v pw="${role_password}" \
                -c "SELECT format('CREATE ROLE %I LOGIN PASSWORD %L', :'role', :'pw') WHERE NOT EXISTS (SELECT FROM pg_roles WHERE rolname = :'role')")"
              if [ -n "${create_role_sql}" ]; then
                psql -v ON_ERROR_STOP=1 -d postgres -c "${create_role_sql}"
              fi

              alter_role_sql="$(psql -v ON_ERROR_STOP=1 -d postgres -A -t \
                -v role="${APP_OWNER}" -v pw="${role_password}" \
                -c "SELECT format('ALTER ROLE %I LOGIN PASSWORD %L', :'role', :'pw')")"
              psql -v ON_ERROR_STOP=1 -d postgres -c "${alter_role_sql}"

              echo "Ensuring database ${APP_DB} exists..."
              db_exists="$(psql -v ON_ERROR_STOP=1 -d postgres -Atc "SELECT 1 FROM pg_database WHERE datname='${APP_DB}'")"
              if [ "${db_exists}" = "1" ]; then
                echo "Database exists; ensuring owner is ${APP_OWNER}..."
                psql -v ON_ERROR_STOP=1 -d postgres -c "ALTER DATABASE \"${APP_DB}\" OWNER TO \"${APP_OWNER}\";"
              else
                echo "Creating database ${APP_DB} owned by ${APP_OWNER}..."
                psql -v ON_ERROR_STOP=1 -d postgres -c "CREATE DATABASE \"${APP_DB}\" OWNER \"${APP_OWNER}\";"
              fi

              echo "Database init complete."
      volumes:
        - name: app-db-auth
          secret:
            secretName: authentik-postgres-auth
            optional: false
