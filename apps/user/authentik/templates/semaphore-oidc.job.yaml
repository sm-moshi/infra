apiVersion: batch/v1
kind: Job
metadata:
  name: authentik-semaphore-oidc-bootstrap
  labels:
    app.kubernetes.io/name: authentik
    app.kubernetes.io/component: bootstrap
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation,HookSucceeded
    argocd.argoproj.io/sync-wave: "10"
    argocd.argoproj.io/sync-options: Replace=true
spec:
  backoffLimit: 3
  template:
    metadata:
      labels:
        app.kubernetes.io/name: authentik
        app.kubernetes.io/component: bootstrap
    spec:
      restartPolicy: Never
      containers:
        - name: bootstrap
          # Reuse authentik server image (already pulled) to avoid extra image dependencies.
          image: ghcr.io/goauthentik/server:2025.12.3
          imagePullPolicy: IfNotPresent
          resources:
            requests:
              cpu: 25m
              memory: 64Mi
            limits:
              cpu: 200m
              memory: 256Mi
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            allowPrivilegeEscalation: false
          env:
            - name: AUTHENTIK_BOOTSTRAP_TOKEN
              valueFrom:
                secretKeyRef:
                  name: authentik-config
                  key: bootstrap_token
            - name: AUTHENTIK_BASE_URL
              value: http://authentik-server.apps.svc.cluster.local
            - name: SEMAPHORE_OIDC_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  name: semaphore-oidc
                  key: client_id
            - name: SEMAPHORE_OIDC_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: semaphore-oidc
                  key: client_secret
            - name: SEMAPHORE_REDIRECT_URI
              value: https://semaphore.m0sh1.cc/api/auth/oidc/authentik/redirect
          command:
            - /bin/sh
            - -ec
            - |
              python - <<'PY'
              import json
              import os
              import urllib.parse
              import urllib.request

              base = os.environ["AUTHENTIK_BASE_URL"].rstrip("/")
              token = os.environ["AUTHENTIK_BOOTSTRAP_TOKEN"].strip()
              client_id = os.environ["SEMAPHORE_OIDC_CLIENT_ID"].strip()
              client_secret = os.environ["SEMAPHORE_OIDC_CLIENT_SECRET"].strip()
              redirect_uri = os.environ["SEMAPHORE_REDIRECT_URI"].strip()

              if not token:
                raise SystemExit("AUTHENTIK_BOOTSTRAP_TOKEN is empty")
              if not client_id:
                raise SystemExit("SEMAPHORE_OIDC_CLIENT_ID is empty")
              if not client_secret:
                raise SystemExit("SEMAPHORE_OIDC_CLIENT_SECRET is empty")
              if not redirect_uri:
                raise SystemExit("SEMAPHORE_REDIRECT_URI is empty")

              def req(method, path, body=None, query=None):
                url = base + path
                if query:
                  url += "?" + urllib.parse.urlencode(query)
                data = None
                headers = {
                  "Authorization": f"Bearer {token}",
                  "Accept": "application/json",
                }
                if body is not None:
                  data = json.dumps(body).encode("utf-8")
                  headers["Content-Type"] = "application/json"
                r = urllib.request.Request(url, data=data, headers=headers, method=method)
                try:
                  with urllib.request.urlopen(r, timeout=30) as resp:
                    raw = resp.read().decode("utf-8") if resp.length != 0 else ""
                    return resp.status, (json.loads(raw) if raw else None)
                except urllib.error.HTTPError as e:
                  raw = e.read().decode("utf-8") if e.fp else ""
                  raise RuntimeError(f"{method} {url} -> {e.code}: {raw[:800]}")

              def list_all(path, key="results", page_size=200):
                status, body = req("GET", path, query={"page_size": page_size})
                if status != 200:
                  raise RuntimeError(f"GET {path} unexpected status {status}")
                return body.get(key, [])

              # Resolve flows by slug.
              flows = list_all("/api/v3/flows/instances/")
              auth_flow = next((f for f in flows if f.get("slug") == "default-authentication-flow"), None)
              if not auth_flow:
                raise RuntimeError("default-authentication-flow not found")
              authz_flow = next((f for f in flows if f.get("slug") == "default-provider-authorization-implicit-consent"), None)
              if not authz_flow:
                raise RuntimeError("default-provider-authorization-implicit-consent not found")
              invalidation_flow = next((f for f in flows if f.get("slug") == "default-provider-invalidation-flow"), None)
              if not invalidation_flow:
                raise RuntimeError("default-provider-invalidation-flow not found")

              # Ensure OAuth2/OIDC provider exists.
              provider_name = "m0sh1-semaphore-oidc"
              providers = list_all("/api/v3/providers/oauth2/")
              provider = next((p for p in providers if p.get("name") == provider_name), None)

              desired = {
                "name": provider_name,
                "authorization_flow": authz_flow["pk"],
                "authentication_flow": auth_flow["pk"],
                "client_id": client_id,
                "client_secret": client_secret,
                "client_type": "confidential",
                "redirect_uris": [{"matching_mode": "strict", "url": redirect_uri}],
                "include_claims_in_id_token": True,
                "issuer_mode": "per_provider",
                "sub_mode": "hashed_user_id",
                "invalidation_flow": invalidation_flow["pk"],
              }

              if provider:
                pk = provider["pk"]
                # PATCH must include required fields to avoid accidental clearing.
                patch = {
                  "client_id": client_id,
                  "client_secret": client_secret,
                  "redirect_uris": [{"matching_mode": "strict", "url": redirect_uri}],
                }
                if any(provider.get(k) != v for k, v in patch.items()):
                  req("PATCH", f"/api/v3/providers/oauth2/{pk}/", body=patch)
              else:
                _, created = req("POST", "/api/v3/providers/oauth2/", body=desired)
                pk = created["pk"]

              # Ensure application exists and points to this provider.
              app_slug = "semaphore"
              apps = list_all("/api/v3/core/applications/")
              app = next((a for a in apps if a.get("slug") == app_slug), None)
              if app:
                app_pk = app["pk"]
                if app.get("provider") != pk:
                  req("PATCH", f"/api/v3/core/applications/{app_pk}/", body={"provider": pk})
              else:
                body = {
                  "name": "Semaphore",
                  "slug": app_slug,
                  "provider": pk,
                  "meta_launch_url": "https://semaphore.m0sh1.cc",
                  "open_in_new_tab": True,
                }
                req("POST", "/api/v3/core/applications/", body=body)

              print("ok")
              PY
