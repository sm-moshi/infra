# apps/user/harbor/templates/bootstrap.yaml
{{- if .Values.bootstrap.enabled }}
apiVersion: v1
kind: ServiceAccount
metadata:
  name: harbor-bootstrap
  namespace: {{ .Release.Namespace }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: harbor-bootstrap
  namespace: {{ .Release.Namespace }}
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list", "create", "patch", "update"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: harbor-bootstrap
  namespace: {{ .Release.Namespace }}
subjects:
  - kind: ServiceAccount
    name: harbor-bootstrap
    namespace: {{ .Release.Namespace }}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: harbor-bootstrap
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: harbor-bootstrap-script
  namespace: {{ .Release.Namespace }}
data:
  bootstrap.py: |
    #!/usr/bin/env python3
    import base64
    import json
    import os
    import ssl
    import sys
    import time
    import urllib.error
    import urllib.parse
    import urllib.request

    NAMESPACE = "{{ .Release.Namespace }}"

    def log(message: str) -> None:
      ts = time.strftime("%Y-%m-%dT%H:%M:%S%z")
      print(f"[{ts}] {message}", flush=True)

    def b64_str(value: str) -> str:
      return base64.b64encode(value.encode()).decode()

    HARBOR_URL = os.environ.get("HARBOR_URL")
    if not HARBOR_URL:
      svc_host = os.environ.get("HARBOR_CORE_SERVICE_HOST")
      svc_port = os.environ.get("HARBOR_CORE_SERVICE_PORT", "80")
      if svc_host:
        HARBOR_URL = f"http://{svc_host}:{svc_port}"
      else:
        HARBOR_URL = "http://harbor-core:80"
    HARBOR_URL = HARBOR_URL.rstrip("/")
    HARBOR_HOST = os.environ.get("HARBOR_HOST")
    if not HARBOR_HOST:
      log("HARBOR_HOST is required")
      sys.exit(1)

    try:
      with open("/secrets/admin_password", "r", encoding="utf-8") as fh:
        ADMIN_PASSWORD = fh.read().strip()
    except Exception as exc:
      log(f"Failed to read admin password: {exc}")
      sys.exit(1)

    def auth_header() -> str:
      return f"Basic {b64_str(f'admin:{ADMIN_PASSWORD}')}"

    def harbor_request(method: str, path: str, payload=None, timeout: int = 15):
      url = f"{HARBOR_URL}{path}"
      data = json.dumps(payload).encode() if payload is not None else None
      req = urllib.request.Request(url, data=data, method=method)
      req.add_header("Authorization", auth_header())
      if payload is not None:
        req.add_header("Content-Type", "application/json")
      ctx = ssl._create_unverified_context()
      try:
        with urllib.request.urlopen(req, context=ctx, timeout=timeout) as resp:
          body = resp.read()
          if body:
            return json.loads(body)
          return None
      except urllib.error.HTTPError as exc:
        body = exc.read()
        try:
          err = json.loads(body) if body else None
        except Exception:
          err = body.decode() if body else None
        return {"_error": exc.code, "_body": err}
      except Exception as exc:
        return {"_error": "exception", "_body": str(exc)}

    def harbor_get_list(path: str):
      resp = harbor_request("GET", path)
      if isinstance(resp, dict) and "_error" in resp:
        log(f"Harbor GET {path} failed: {resp['_error']}")
        return []
      return resp or []

    K8S_HOST = os.environ.get("KUBERNETES_SERVICE_HOST")
    K8S_PORT = os.environ.get("KUBERNETES_SERVICE_PORT", "443")
    if not K8S_HOST:
      log("KUBERNETES_SERVICE_HOST is not set")
      sys.exit(1)
    K8S_SERVER = f"https://{K8S_HOST}:{K8S_PORT}"
    TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token"
    CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    try:
      with open(TOKEN_PATH, "r", encoding="utf-8") as fh:
        K8S_TOKEN = fh.read().strip()
    except Exception as exc:
      log(f"Failed to read serviceaccount token: {exc}")
      sys.exit(1)

    K8S_CTX = ssl.create_default_context(cafile=CA_PATH)

    def k8s_request(method: str, path: str, payload=None, timeout: int = 15):
      url = f"{K8S_SERVER}{path}"
      data = json.dumps(payload).encode() if payload is not None else None
      req = urllib.request.Request(url, data=data, method=method)
      req.add_header("Authorization", f"Bearer {K8S_TOKEN}")
      req.add_header("Accept", "application/json")
      if payload is not None:
        req.add_header("Content-Type", "application/json")
      try:
        with urllib.request.urlopen(req, context=K8S_CTX, timeout=timeout) as resp:
          body = resp.read()
          return resp.status, json.loads(body) if body else None
      except urllib.error.HTTPError as exc:
        body = exc.read()
        try:
          data = json.loads(body) if body else None
        except Exception:
          data = None
        return exc.code, data
      except Exception as exc:
        return 0, {"message": str(exc)}

    def k8s_get_secret(name: str):
      code, data = k8s_request("GET", f"/api/v1/namespaces/{NAMESPACE}/secrets/{name}")
      if code == 200:
        return data
      if code == 404:
        return None
      log(f"Kubernetes GET secret {name} failed: {code}")
      return None

    def k8s_create_secret(secret_obj: dict) -> None:
      code, _ = k8s_request("POST", f"/api/v1/namespaces/{NAMESPACE}/secrets", secret_obj)
      if code in (200, 201):
        return
      if code == 409:
        return
      log(f"Kubernetes create secret failed: {code}")

    def decode_secret_field(secret: dict, key: str):
      data = secret.get("data", {}) if secret else {}
      value = data.get(key)
      if not value:
        return None
      try:
        return base64.b64decode(value).decode()
      except Exception:
        return None

    def dockerconfig_secret(name: str, username: str, password: str) -> dict:
      auth = b64_str(f"{username}:{password}")
      cfg = {"auths": {HARBOR_HOST: {"username": username, "password": password, "auth": auth}}}
      encoded = b64_str(json.dumps(cfg))
      return {
        "apiVersion": "v1",
        "kind": "Secret",
        "metadata": {"name": name, "namespace": NAMESPACE},
        "type": "kubernetes.io/dockerconfigjson",
        "data": {".dockerconfigjson": encoded},
      }

    def to_bool(value):
      if isinstance(value, bool):
        return value
      if value is None:
        return False
      if isinstance(value, str):
        return value.lower() == "true"
      return bool(value)

    def wait_harbor():
      log("Waiting for Harbor API...")
      for _ in range(180):
        resp = harbor_request("GET", "/api/v2.0/health")
        if isinstance(resp, dict) and resp.get("status") == "healthy":
          log("Harbor is healthy.")
          return
        time.sleep(2)
      log("Harbor API did not become healthy in time")
      sys.exit(1)

    def load_registry_credentials(secret_name, user_key, pass_key):
      if not secret_name:
        return None
      secret = k8s_get_secret(secret_name)
      if not secret:
        log(f"Registry credential secret {secret_name} not found; using anonymous.")
        return None
      user = decode_secret_field(secret, user_key)
      passwd = decode_secret_field(secret, pass_key)
      if not user or not passwd:
        log(f"Registry credential secret {secret_name} missing keys; using anonymous.")
        return None
      return user, passwd

    def ensure_registry(name, reg_type, url, user, passwd):
      q = urllib.parse.quote(name)
      existing = harbor_get_list(f"/api/v2.0/registries?name={q}")
      reg_id = existing[0].get("id") if existing else None
      if user and passwd:
        credential = {"access_key": user, "access_secret": passwd}
      else:
        credential = {"type": "anonymous"}
      payload = {
        "name": name,
        "type": reg_type,
        "url": url,
        "insecure": False,
        "credential": credential,
      }
      if reg_id:
        harbor_request("PUT", f"/api/v2.0/registries/{reg_id}", payload)
        return reg_id
      harbor_request("POST", "/api/v2.0/registries", payload)
      existing = harbor_get_list(f"/api/v2.0/registries?name={q}")
      return existing[0].get("id") if existing else None

    def project_id_for_name(name):
      q = urllib.parse.quote(name)
      existing = harbor_get_list(f"/api/v2.0/projects?name={q}")
      return existing[0].get("project_id") if existing else None

    def ensure_project_proxy(name, registry_id, public_flag):
      existing = project_id_for_name(name)
      metadata = {
        "auto_scan": "true",
        "reuse_sys_cve_whitelist": "true",
        "severity": "high",
        "proxy_cache": "true",
      }
      if existing:
        harbor_request("PUT", f"/api/v2.0/projects/{existing}", {"metadata": metadata})
        return existing
      payload = {
        "project_name": name,
        "public": to_bool(public_flag),
        "registry_id": registry_id,
        "metadata": metadata,
      }
      harbor_request("POST", "/api/v2.0/projects", payload)
      return project_id_for_name(name)

    def ensure_project(name, public_flag, autoscan_flag):
      existing = project_id_for_name(name)
      metadata = {
        "auto_scan": "true" if to_bool(autoscan_flag) else "false",
        "reuse_sys_cve_whitelist": "true",
        "severity": "high",
      }
      if existing:
        harbor_request("PUT", f"/api/v2.0/projects/{existing}", {"metadata": metadata})
        return existing
      payload = {"project_name": name, "public": to_bool(public_flag), "metadata": metadata}
      harbor_request("POST", "/api/v2.0/projects", payload)
      return project_id_for_name(name)

    def ensure_robot_secret(project_id, project_name, robot_name, description, secret_name, access_list):
      if k8s_get_secret(secret_name):
        log(f"Secret {secret_name} already exists, skipping robot creation.")
        return
      try:
        project_id = int(project_id)
      except Exception:
        log(f"Invalid project_id {project_id} for robot {robot_name}, skipping.")
        return
      full_name = f"robot${project_name}+{robot_name}"
      robots = harbor_get_list(f"/api/v2.0/robots?project_id={project_id}")
      if any(r.get("name") == full_name for r in robots):
        log(f"Robot {full_name} already exists; secret {secret_name} not created.")
        return
      permissions = [{"kind": "project", "namespace": project_name, "access": []}]
      for action in access_list:
        permissions[0]["access"].append({"action": action, "resource": "repository"})
      payload = {
        "name": robot_name,
        "description": description,
        "level": "project",
        "project_id": project_id,
        "disable": False,
        "duration": -1,
        "permissions": permissions,
      }
      robot_resp = harbor_request("POST", "/api/v2.0/robots", payload)
      if isinstance(robot_resp, dict) and "_error" in robot_resp:
        log(f"Robot creation failed for {robot_name}: {robot_resp['_error']}")
        return
      robot_full_name = robot_resp.get("name")
      robot_secret = robot_resp.get("secret")
      if not robot_full_name or not robot_secret:
        log(f"Robot creation response incomplete for {robot_name}")
        return
      k8s_create_secret(dockerconfig_secret(secret_name, robot_full_name, robot_secret))
      log(f"Created robot secret {secret_name}")

    def load_user_credentials(user_secret, user_key, pass_key):
      if not user_secret:
        return None
      secret = k8s_get_secret(user_secret)
      if not secret:
        log(f"User credential secret {user_secret} not found.")
        return None
      user = decode_secret_field(secret, user_key)
      passwd = decode_secret_field(secret, pass_key)
      if not user or not passwd:
        log(f"User credential secret {user_secret} missing keys.")
        return None
      return user, passwd

    def ensure_user(username, password, full_name, email):
      q = urllib.parse.quote(username)
      existing = harbor_get_list(f"/api/v2.0/users/search?username={q}")
      if existing:
        return
      payload = {"username": username, "password": password, "realname": full_name, "email": email}
      harbor_request("POST", "/api/v2.0/users", payload)

    def ensure_project_member(project_id, username, role_id):
      try:
        role_id = int(role_id)
      except Exception:
        log(f"Invalid roleId {role_id} for {username}, skipping.")
        return
      payload = {"role_id": role_id, "member_user": {"username": username}}
      harbor_request("POST", f"/api/v2.0/projects/{project_id}/members", payload)

    def ensure_user_registry_secret(secret_name, username, password):
      if k8s_get_secret(secret_name):
        log(f"Secret {secret_name} already exists, skipping.")
        return
      k8s_create_secret(dockerconfig_secret(secret_name, username, password))
      log(f"Created user registry secret {secret_name}")

    wait_harbor()

    PROXY_CACHES = json.loads(r'''{{ toJson .Values.bootstrap.proxyCaches }}''') or []
    for cfg in PROXY_CACHES:
      reg_name = cfg.get("registryName")
      reg_type = cfg.get("registryType")
      reg_url = cfg.get("url")
      reg_public = cfg.get("public")
      cred_secret = cfg.get("credentialSecret")
      cred_user_key = cfg.get("credentialUsernameKey", "username")
      cred_pass_key = cfg.get("credentialPasswordKey", "password")
      creds = load_registry_credentials(cred_secret, cred_user_key, cred_pass_key)
      cred_user, cred_pass = (creds if creds else (None, None))
      reg_id = ensure_registry(reg_name, reg_type, reg_url, cred_user, cred_pass)
      proj_name = cfg.get("name")
      if reg_id:
        proj_id = ensure_project_proxy(proj_name, reg_id, reg_public)
      else:
        proj_id = None
      for robot in cfg.get("robots", []) or []:
        robot_name = robot.get("name")
        robot_desc = robot.get("description", "")
        robot_access = robot.get("access", ["pull"])
        if proj_id:
          ensure_robot_secret(proj_id, proj_name, robot_name, robot_desc, f"harbor-robot-{robot_name}", robot_access)
        else:
          log(f"Skipping robot creation for {proj_name}; project ID not found.")

    PROJECTS = json.loads(r'''{{ toJson .Values.bootstrap.projects }}''') or []
    for proj in PROJECTS:
      proj_name = proj.get("name")
      proj_public = proj.get("public")
      proj_autoscan = proj.get("autoScan")
      proj_id = ensure_project(proj_name, proj_public, proj_autoscan)
      for robot in proj.get("robots", []) or []:
        robot_name = robot.get("name")
        robot_desc = robot.get("description", "")
        robot_access = robot.get("access", ["push", "pull"])
        if proj_id:
          ensure_robot_secret(proj_id, proj_name, robot_name, robot_desc, f"harbor-robot-{robot_name}", robot_access)
        else:
          log(f"Skipping robot creation for {proj_name}; project ID not found.")

    USERS = json.loads(r'''{{ toJson .Values.bootstrap.users }}''') or []
    for user in USERS:
      user_secret = user.get("passwordSecret")
      user_secret_key = user.get("passwordKey", "password")
      user_user_key = user.get("usernameKey", "username")
      creds = load_user_credentials(user_secret, user_user_key, user_secret_key)
      if not creds:
        log(f"Skipping user creation; missing credentials for {user.get('name')}")
        continue
      username, password = creds
      full_name = user.get("fullName") or username
      email = user.get("email") or f"{username}@local"
      ensure_user(username, password, full_name, email)
      for proj in user.get("projects", []) or []:
        proj_name = proj.get("name")
        role_id = proj.get("roleId")
        proj_id = project_id_for_name(proj_name)
        if proj_id:
          ensure_project_member(proj_id, username, role_id)
        else:
          log(f"Skipping project membership for {proj_name}; project ID not found.")
      secret_name = user.get("dockerSecretName")
      if secret_name:
        ensure_user_registry_secret(secret_name, username, password)

    log("Harbor bootstrap complete.")
---
apiVersion: batch/v1
kind: Job
metadata:
  name: harbor-bootstrap
  namespace: {{ .Release.Namespace }}
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: HookSucceeded,BeforeHookCreation
spec:
  backoffLimit: {{ .Values.bootstrap.backoffLimit | default 2 }}
  ttlSecondsAfterFinished: {{ .Values.bootstrap.ttlSecondsAfterFinished | default 300 }}
  template:
    spec:
      serviceAccountName: harbor-bootstrap
      restartPolicy: OnFailure
      {{- if .Values.bootstrap.nodeSelector }}
      nodeSelector:
{{ toYaml .Values.bootstrap.nodeSelector | indent 8 }}
      {{- end }}
      containers:
        - name: bootstrap
          image: "{{ .Values.bootstrap.image.repository }}:{{ .Values.bootstrap.image.tag }}"
          imagePullPolicy: IfNotPresent
          {{- if .Values.bootstrap.resources }}
          resources:
{{ toYaml .Values.bootstrap.resources | indent 12 }}
          {{- end }}
          env:
            - name: HARBOR_HOST
              value: {{ .Values.bootstrap.registryHost | quote }}
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            allowPrivilegeEscalation: false
            capabilities:
              drop: ["ALL"]
            seccompProfile:
              type: RuntimeDefault
          volumeMounts:
            - name: script
              mountPath: /scripts
            - name: harbor-admin
              mountPath: /secrets
              readOnly: true
          command: ["python", "/scripts/bootstrap.py"]
      volumes:
        - name: script
          configMap:
            name: harbor-bootstrap-script
            defaultMode: 0755
        - name: harbor-admin
          secret:
            secretName: harbor-admin
            items:
              - key: HARBOR_ADMIN_PASSWORD
                path: admin_password
{{- end }}
