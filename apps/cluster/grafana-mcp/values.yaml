grafana-mcp:
  fullnameOverride: grafana-mcp
  namespaceOverride: monitoring

  # Allow pulling from Docker Hardened Images (DHI) and/or Harbor proxy caches
  # where the DHI auth secret is reflected into namespaces.
  global:
    imagePullSecrets:
      - name: kubernetes-dhi
  imagePullSecrets:
    - name: kubernetes-dhi

  image:
    registry: harbor.m0sh1.cc
    repository: dhi/grafana-mcp
    tag: "0.9.0"
    pullPolicy: IfNotPresent

  grafana:
    # kube-prometheus-stack's Grafana service port is 80 -> targetPort 3000.
    url: "http://kube-prometheus-stack-grafana.monitoring"
    # Do NOT set grafana.apiKey in Git (plaintext). Instead, create a SealedSecret
    # in the monitoring namespace and reference it here.
    apiKeySecret:
      name: grafana-mcp-api-key
      key: grafana-mcp-api-key

  # By default, the server can start in stdio mode (meant for local CLI usage),
  # which immediately exits in Kubernetes. Force remote transport + bind address.
  extraArgs:
    - -t
    - streamable-http
    - --address
    - 0.0.0.0:8000
    # Serve the MCP endpoint under /mcp so we can route it behind Traefik
    # on the existing Grafana hostname without port-forwarding.
    - --base-path
    - /mcp

  readinessProbe:
    httpGet:
      path: /mcp/healthz
      port: mcp-http
    initialDelaySeconds: 3
    periodSeconds: 10
    timeoutSeconds: 1
    failureThreshold: 3

  livenessProbe:
    httpGet:
      path: /mcp/healthz
      port: mcp-http
    initialDelaySeconds: 10
    periodSeconds: 20
    timeoutSeconds: 1
    failureThreshold: 3

  debug: false
  disabledCategories: []

# Expose MCP on https://grafana.m0sh1.cc/mcp/ via Traefik (CRD IngressRoute).
# We use an IngressRoute (not a Kubernetes Ingress) because Grafana itself is
# already exposed via an IngressRoute in kube-prometheus-stack.
ingressRoute:
  enabled: true
  host: grafana.m0sh1.cc
  entryPoints:
    - websecure
  pathPrefix: /mcp
  servicePort: 8000
  tls:
    secretName: wildcard-m0sh1-cc
